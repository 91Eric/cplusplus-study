[TOC]

# 操作符重载
> C++ 中的重载可以扩展已有操作符的功能

> 操作符的重载是以函数的方式实现的
> > 操作符的重载在本质上是使用特殊形式的函数扩展操作符的功能

## 实现方式
> 通过定义新的关键字**operator**定义特殊的函数
> > operator本质是通过定义函数的方式对操作符进行重载
### 语法形式

> 运算符重载有两种位置，一种是作为类成员函数，另外一种是作为类的友元函数.两者除了由于一些限制导致必须是成员函数之外，在功能上没区别，但是作为类成员时，实际少了左边一个参数，这是由于作为类成员函数，其中一个操作对象肯定是调用运算符的类对象本身，因此使用this指针代替了本身这一参数

#### 类的友元形式
```
class Test
{
    public:
        friend Type operator Sign(const Type p1, const Type p2);
}
Type operator Sign(const Type p1, const Type p2)
{
    Type ret;

    return ret;
}
```

> 其中Sign就是想要重载的运算符，如常见的 +,-,*,/，当然其他的自增等都可以，只不过有的不建议或者不允许重载

##### 示例
> 下面这段代码是为了实现一个自定义的复数类实现对象相加功能
```
类的友元实现方式-
#include <cstdio>

class Complex
{
    private:
        int x;
        int y;
    public:
        Complex(): x(0), y(0)
        {

        }
        Complex(int x, int y)
        {
            this->x = x;
            this->y = y;
        }
        friend Complex operator +(const Complex& p1, const Complex& p2);
};

Complex operator +(const Complex& p1, const Complex& p2)
{
    Complex ret;
    ret.x = p1.x + p2.x;
    ret.x = p1.x + p2.x;
    ret.y = p1.y + p2.y;
    return ret;
}

int main(int argc, char const *argv[])
{
    Complex c1(1, 2);
    Complex c2(2, 3);
    Complex c3 = operator +(c1, c2);    // 调用方式1
    Complex c4 = c3 + c2;               // 调用方式2

    return 0;
}

```
> 编译器在发现两个类相加的时候就会去全局空间里找有没有operator+ 重载运算符，如果有就看看操作的对象是不是和重载运算符的形匹配，匹配就可以调用

[疑问]： 参数匹配是精确匹配还是可以做类型转换，我觉得不管是不是精确匹配最好是自己类负责自己的，不要搞事情，增加复杂度

#### 类成员函数
> 和作为友元相比，作为类成员函数，有以下特点或优势
1. 定义时少了左边一个参数，这是由于作为类成员函数，其中一个操作对象肯定是调用运算符的类对象本身，因此使用**this**指针代替了本身这一参数
2. 不需要依赖友元，不会破坏封装性
3. 编译器**优先**在类的成员函数中查找操作符重载函数

```
class Test
{
    public:
        friend Type operator Sign(cconst Type p2);
}
```

##### 示例
```
#include <cstdio>

class Complex
{
    private:
        int x;
        int y;
    public:
        Complex(): x(0), y(0)
        {

        }
        Complex(int x, int y)
        {
            this->x = x;
            this->y = y;
        }
        Complex operator +(const Complex& p2)
        {
            printf("class\n");
            Complex ret;

            ret.x = this->x + p2.x;
            ret.x = this->y + p2.y;
            
            return ret;
        }
    friend Complex operator +(const Complex& p1, const Complex& p2);
};

Complex operator +(const Complex& p1, const Complex& p2)
{
    printf("friend\n");
    Complex ret;
    ret.x = p1.x + p2.x;
    ret.y = p1.y + p2.y;
    return ret;
}

int main(int argc, char const *argv[])
{
    Complex c1(1, 2);
    Complex c2(2, 3);
    Complex c3 = c1 + c2;
    return 0;
}

输出：
class 说明优先使用类内的
```

> 第二种相比于第一种有优势，但是还是有优化的余地，或者说上面的代码只是实现了功能，我们的实现应该和原生语义一致，例如上面的代码就**不支持连加操作**（如果上面连加你会发现其实结果是前两个对象相加的结果），但是`+`的原生语义是支持的，解决方法就是返回值改为引用

#### 最终形式

```
#include <cstdio>

class Complex
{
    public:
        int x;
        int y;
    public:
        Complex(): x(0), y(0)
        {

        }
        Complex(int x, int y)
        {
            printf("Complex\n");
            this->x = x;
            this->y = y;
        }
        Complex(const Complex& oth)
        {
            printf("Complex&\n");
            x = oth.x;
            y = oth.y;
        }
        Complex& operator +(const Complex& p2)
        {
            printf("class\n");

            this->x = this->x + const_cast<Complex&>(p2).x;
            this->y = this->y + const_cast<Complex&>(p2).y;
            
            return *this;
        }
    friend Complex operator +(const Complex& p1, const Complex& p2);
};

Complex operator +(const Complex& p1, const Complex& p2)
{
    printf("friend\n");
    Complex ret;
    ret.x = p1.x + p2.x;
    ret.y = p1.y + p2.y;
    return ret;
}

int main(int argc, char const *argv[])
{
    Complex c1(1, 2);
    Complex c2(2, 3);
    Complex c3(2, 3);

    Complex c4 = c1 + c2 + c3;
    printf("%d\n", c4.x);
    return 0;
}

输出：
Complex
Complex
Complex
class
class
5

```

## 操作符重载小结
1. 常用的运算符都可以通过operator关键字实现重载，**通常**存在两种实现方式：友元函数和类成员函数
2. 赋值操作符 ***必须*** 是成员函数，且必须处理自我赋值的情况
3. 操作符的重载需要符合原生语义，**不应**该改变其原生语义
4. 操作符的重载**不能**改变原先操作符的优先级
5. 操作符重载**不能**改变操作数个数

# 各种操作符的重载

## 数组访问操作符重载
> 像string 类这种对象支持像数组一样支持通过下标访问某个元素的操作,这就是调用了数组访问操作符,作为内置的操作符,数组操作符同样支持重载

### 注意事项
1. **只能**通过类成员函数形式重载
2. 重载函数**能且仅能**使用一个参数
3. 可以进行函数重载

### 示例

#### 基础版本
```
/**
 * @author Eric
 * @file Description 数组类头文件
 * @desc Created on 2019-11-24 4:48:07 pm
 * @copyright
 */
#ifndef __INTARRAY_H__
#define __INTARRAY_H__

class IntArray
{
    private:
        int m_len;
        int *m_pointer;
        
        IntArray(int len);
        bool init();
    public:
        static IntArray* new_instance(int len);
        // 拷贝构造不允许，因为拷贝构造其实也需要和二阶构造的，
        // 因为只是换了一个方式构造一个新对象而已，
        // 两者唯一的区别就是拷贝构造会把原先的值拷贝过来而不是默认全零
        // IntArray(const IntArray& other);
        ~IntArray();
        int length();
        int& operator [](int idx);
        bool set_elem(int pos, int value);
        bool get_elem(int pos, int &value);
};

#endif

/**
 * @author Eric
 * @file Description 数组类对象实现
 * @desc Created on 2019-11-24 4:42:41 pm
 * @copyright 
 */
#include "IntArray.h"
#include <cstdio>
#include <cstdlib>
#include <new>
#include <iostream>

using namespace std;

IntArray::IntArray(int len)
{
    m_len = len;
}

bool IntArray::init()
{
    m_pointer = new(std::nothrow) int[m_len];
    if (m_pointer)
    {
        for (int i = 0; i < m_len; i++)
        {
            m_pointer[i] = 0;
        }
        return true;
    }
    else
    {
        m_len = 0;
        return false;
    }
}

IntArray*  IntArray::new_instance(int len)
{
    IntArray *ret = new IntArray(len);

    if (!(ret && ret->init()))
    {
        delete ret;
        return NULL;
    }

    return ret;
}

int IntArray::length()
{
    return m_len;
}

bool IntArray::set_elem(int pos, int value)
{
    int ret = (pos >= 0) && (pos < m_len);
    if (ret)
    {
        m_pointer[pos] = value;
    }
    return ret;
}

bool IntArray::get_elem(int pos, int &value)
{
    int ret = (pos >= 0) && (pos < m_len);
    if (ret)
    {
        value = m_pointer[pos];
    }
    return ret;
}

// IntArray::IntArray(const IntArray& other)
// {
//     m_len = other.m_len;

//     m_pointer = new(nothrow) int[m_len];

//     for (int i = 0; i < m_len; i++)
//     {
//         m_pointer[i] = other.m_pointer[i];
//     }
//    
/*
    
*/
// }

int& IntArray::operator [](int idx)
{
    return m_pointer[idx];
}

IntArray::~IntArray()
{
    m_len = 0;
    delete[] m_pointer;
}

int main(int argc, char const *argv[])
{
    IntArray *p = IntArray::new_instance(3);
    (*p)[1] = 1;
    cout << (*p)[1] << endl;
    return 0;
}

输出:
1

```

> 上面的例子中出现了指针, 那有没有什么方法去除呢,方法是有的,一种是智能指针,一种是下面的方法,通过增加一个成员函数返回自身的引用,通过这个对象引用来对对象进行操作
#### 改进版本

```
/**
 * @author Eric
 * @file Description 数组类头文件
 * @desc Created on 2019-11-24 4:48:07 pm
 * @copyright
 */
#ifndef __INTARRAY_H__
#define __INTARRAY_H__

class IntArray
{
    private:
        int m_len;
        int *m_pointer;
        
        IntArray(int len);
        bool init();
    public:
        static IntArray* new_instance(int len);
        // 拷贝构造不允许，因为拷贝构造其实也需要和二阶构造的，
        // 因为只是换了一个方式构造一个新对象而已，
        // 两者唯一的区别就是拷贝构造会把原先的值拷贝过来而不是默认全零
        // IntArray(const IntArray& other);
        ~IntArray();
        int length();
        int& operator [](int idx);
        IntArray& self();
        bool set_elem(int pos, int value);
        bool get_elem(int pos, int &value);
};

#endif


/**
 * @author Eric
 * @file Description 数组类对象实现
 * @desc Created on 2019-11-24 4:42:41 pm
 * @copyright 
 */
#include "IntArray.h"
#include <cstdio>
#include <cstdlib>
#include <new>
#include <iostream>

using namespace std;

IntArray::IntArray(int len)
{
    m_len = len;
}

bool IntArray::init()
{
    m_pointer = new(std::nothrow) int[m_len];
    if (m_pointer)
    {
        for (int i = 0; i < m_len; i++)
        {
            m_pointer[i] = 0;
        }
        return true;
    }
    else
    {
        m_len = 0;
        return false;
    }
}

IntArray*  IntArray::new_instance(int len)
{
    IntArray *ret = new IntArray(len);

    if (!(ret && ret->init()))
    {
        delete ret;
        return NULL;
    }

    return ret;
}

int IntArray::length()
{
    return m_len;
}

bool IntArray::set_elem(int pos, int value)
{
    int ret = (pos >= 0) && (pos < m_len);
    if (ret)
    {
        m_pointer[pos] = value;
    }
    return ret;
}

bool IntArray::get_elem(int pos, int &value)
{
    int ret = (pos >= 0) && (pos < m_len);
    if (ret)
    {
        value = m_pointer[pos];
    }
    return ret;
}

// IntArray::IntArray(const IntArray& other)
// {
//     m_len = other.m_len;

//     m_pointer = new(nothrow) int[m_len];

//     for (int i = 0; i < m_len; i++)
//     {
//         m_pointer[i] = other.m_pointer[i];
//     }
//    
/*
    
*/
// }

int& IntArray::operator [](int idx)
{
    return m_pointer[idx];
}

IntArray& IntArray::self()
{
    return *this;
}

IntArray::~IntArray()
{
    m_len = 0;
    delete[] m_pointer;
}

int main(int argc, char const *argv[])
{
    IntArray* p = IntArray::new_instance(3);
    IntArray& arr = p->self();  // 通过返回引用,改变调用方式
    arr[1] = 1;
    cout << arr[1] << endl;
    return 0;
}

```

---

## 函数对象
> 函数对象是指可以像调用一个函数一样使用一个类对象进行函数调用,形式如下

```
class Test
{};

Test t;
t();

```
### 为什么要有函数对象存在
> 要实现这种效果其实就是重载函数调用操作符,为什么要重载这种运算符或者说函数对象的意义何在?

> 当我们需要维护中间状态,每次调用可以重复使用,有如下问题
1. 函数可以获得斐波那契数列每项的值
2. 每调用一次返回一个值(每次调用都是前一个数值的下一个数值)
3. 函数可根据需求重复使用
4. 可以设置起始项

> 当然我们可以使用全局变量维护中间状态,但是无法重复使用,即如果调用过一次以后,其他的想要使用其他项数的值时,没法在不影响原先状态的基础上完成(肯定要把状态变量给重新赋值,原先的结果也会被覆盖掉),此时就可以通过函数调用操作符重载来构造函数对象

### 实现方式
```
#include <iostream>

using namespace std;

class Fib
{
    private:
        int m_a0;
        int m_a1;
    public:
        // 默认从第1项开始
        Fib():m_a0(0), m_a1(1)
        {
            
        }
        // 指定从第几项开始的数列
        Fib(int start):m_a0(0), m_a1(1)
        {
            for (int i = 2; i <= start; i++)
            {
                int t = m_a1;
                m_a1 = m_a0 + m_a1;
                m_a0 = t;
            }
        }
        // 每一次计算都会计算出下一次的值,返回要求的项的值
        int operator ()()
        {
            int ret = m_a1;
            m_a1 = m_a0 + m_a1;
            m_a0 = ret;

            return ret;
        }
};

int main(int argc, char const *argv[])
{
    Fib fib1;
    int i = 10;
    while (i-- > 0)
    {
        cout << fib1() << endl;
    }

    cout << "..." << endl; 
    Fib fib2(3);

    cout << fib2() << endl;

    return 0;
}

输出:
1
1
2
3
5
8
13
21
34
55
...
2
```
### 函数调用操作符重载小结
1. 只能使用类成员函数重载的方式实现
2. 可以通过函数重载实现不同功能
3. 在工程中用于代替函数指针

