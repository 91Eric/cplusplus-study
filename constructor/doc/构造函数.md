# 构造函数

## 定义
> 构造函数与类名同名且没有返回值，但是参数是不定的
```
class Test
{
    public:
        Test();
        Test(int i);

};
```
## 构造函数的种类
<!-- > 这里说的构造函数不只是说前面定义的构造函数 -->
### 默认构造函数
> 默认构造函数是指没有参数的构造函数，默认情况下如果没有手动写构造函数（这几种任意一种），编译器会默认生成默认构造函数（深入探索c++对象模型中对此事实做出了细致说明，并不是每个类都会默认生成），且函数体为空
```
class Test
{
    public:
        Test();
};
```

### 重载的默认构造函数
> 就是有参数的默认构造函数而已

### 拷贝构造函数
> 拷贝构造函数用于使用一个已经存在的对象初始化一个新对象的时候,参数是 const class_name&，默认会生成这个函数
```
class Test
{
    public:
        Test(const Test &other);

};
```
#### 存在的意义
> 兼容c的初始化方式，这是用于初始化的，所有从这方面就能区分拷贝构造和赋值运算符
> 初始化行为能够符合预期逻辑，这里就涉及到浅拷贝和深拷贝，因为默认的是浅拷贝，而这在某些情况下和我们的预期不一致
##### 浅拷贝
> 按位拷贝，原始对象和新对象是同一份,可以理解为都指向同一个内存，在物理状态上相同
##### 深拷贝
> 按值拷贝，新对象是重新分配空间，指向不同的内存，在逻辑状态上是一致的，即变量的值是一样的

### 转换构造函数
> 转换构造函数其实就是提供的一种由其他类型变量构造类对象的构造函数，其实就是前两种构造函数，如下例子
```
class Test
{
    public:
        Test(int i){}

};

Test b = 1; // 此时就是使用了Test(int i)这个转换构造函数构造对象
```

> 其实这是一种种隐式类型转换，如果可以最好禁止，那么可以使用explicit关键字放在构造函数声明前面即可，那么就只能使用如下方式生成对象
```
class Test
{
    public:
        explicit Test(int i){}      // explicit 说明这个函数 不支持隐式类型转换，
};

Test b(1);   // ok
Test bb = 1; // error
```
### 类型转换构造函数
> 这个和转换构造函数功能刚好相反

## 构造函数使用的时机
> 一般以下几种情况必须需要手动去实现构造函数
1. 需要申请动态内存的
2. 使用了系统资源需要初始化的
3. 想要显式初始化一些成员变量

## 注意
> 构造函数只是用来初始化一个对象，表明的是对象的初始化时机而不是对象的诞生