[TOC]

# 赋值兼容性

> 子类和父类之间的赋值兼容性是指如下几种情况
1 子类对象可以直接赋值给父类对象
2 子类对象可以直接初始化父类对象
3 父类指针可以直接指向子类对象
4 父类引用可以直接引用子类对象

## 示例

```C++
#include <iostream>

using namespace std;

class Parent
{
public:
    void test()
    {
        cout << "Parent" << endl;
    }
};

class Child : public Parent
{
public:
    void test2()
    {
        cout << "Child" << endl;
    }
};

int main()
{
    Parent p1 = Child();
    Child c1;
    Parent p2 = c1;
    Parent *pp1 = &c1;
    Parent &rp1 = c1;
    return 0;
}

```

> 上面的代码是可以编译通过的，这里我们要引入下一个问题，如果使用父类对象调用子类函数会发生什么，如果还是上面的类定义，如下代码

```C++
int main()
{
    Parent p1 = Child();
    p1.test2();
    Child c1;
    Parent p2 = c1;
    p2.test2();
    Parent *pp1 = &c1;
    pp1->test2();
    Parent &rp1 = c1;
    rp1.test2();
    return 0;
}
输出：
classjr.cpp:26:8: error: ‘class Parent’ has no member named ‘test2’
     p1.test2();
        ^
classjr.cpp:29:8: error: ‘class Parent’ has no member named ‘test2’
     p2.test2();
        ^
classjr.cpp:31:10: error: ‘class Parent’ has no member named ‘test2’
     pp1->test2();
          ^
classjr.cpp:33:9: error: ‘class Parent’ has no member named ‘test2’
     rp1.test2();

```

> 我们会发现此时父类对象没法调用子类的成员函数或变量，这里就要提前引出一个概念，**类对象**的**静态类型和动态类型**
>> 静态类型指的就是定义变量时前面的类型修饰符，类对象只有这一种属性
>> 动态类型则是指指针或引用实际指向的数据类型，这种属性只对指针或引用有效且在多态的时候才会有体现

> 结合上面两个定义我们来解释上面的代码，对于p1和p2只有静态属性，此时他们俩就是Parent类型的数据，此时子类对象直接退化为父类对象，因此没法调用子类的成员函数。对于后两者pp1和rp1，他们俩的静态属性也是Parent，但是他们的动态属性却是由指向的子类对象决定的，因此他们的动态类型是Child，但是此时他们调用的是非虚函数（后面会介绍虚函数），因此动态属性不生效，此时还是退化为Parent类型，因此还是只能调用父类的成员函数

> 我们再次抛出一个问题，如果在赋值兼容性的情况下，父类和子类定义了同名函数会怎样，会不会报错，调用以那个为准

> 首先不会报错，因为两个函数的作用域不同，类似属于不同的命名空间，第二个答案很明显，以父类为准，因为此时类对象的静态类型起效。那么就引出下一个问题：父子间同名覆盖问题

## 小结

1.存在赋值兼容时，子类对象会退化为父类对象
1 存在赋值兼容时，变量的静态类型决定了非虚函数的调用,即只能访问父类的成员

# 父子间同名覆盖问题

> 由前面的代码可知，当存在赋值兼容性问题时，非虚函数以静态类型为准，此时所有函数都是调用父类的，那么如果不存在赋值兼容性时即子类对象调用同名函数，父子间存在同名函数会怎样

> 如下代码

```C++
#include <iostream>

using namespace std;

class Parent
{
public:
    void test()
    {
        cout << "Parent" << endl;
    }
};

class Child : public Parent
{
public:
    void test()
    {
        cout << "Child" << endl;
    }
};

int main()
{

    Child c1;

    c1.test();

    return 0;
}

输出：
Child

```

> 此时发生了同名覆盖现象，即当父类和子类定义了**同名的非虚函数**，那么父类的同名函数会全部被隐藏掉（不管参数和返回值，这不是函数重载）,，无法 ***直接*** 通过子类对象调用， ~~此时不是函数重载~~，因为函数重载的首要条件就是在同一作用域下，显然现在是在两个类中，作用域不同，如果想要调用，必须采用如下格式，var.Parent::func的形式

```C++
c1.Parent::test()

```

> 如果上述代码使用父类对象调用会怎样

```C++
#include <iostream>

using namespace std;

class Parent
{
public:
    void test()
    {
        cout << "Parent" << endl;
    }
};

class Child : public Parent
{
public:
    void test()
    {
        cout << "Child" << endl;
    }
};

int main()
{

    Child c1;
    Parent p1(c1);
    p1.test();
    Parent *pp1 = &c1;
    pp1->test();

    return 0;
}

输出：
Parent
Parent
```

## 问题分析

> 这里涉及到静态类型和动态类型，对于**非虚函数和成员变量**，其静态类型决定了函数调用的范围，而静态类型是**编译期间**确定的，此时编译器只能获取到的父类对象或指针的类型，引用的静态类型都是父类，因此只能调用父类的同名成员函数，如果是虚函数，那么会根据其动态类型在运行期间确定调用函数

## 小结

1.不要在父类和子类之间定义同名的非虚函数
2.子类对象只会调用子类内部的同名函数，父类中同名函数被覆盖了
2.父类对象永远只会调用父类的非虚函数或成员变量
